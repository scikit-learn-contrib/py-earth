

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Introduction &mdash; py-earth 0.1.0 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="_static/gallery.css" type="text/css" />
  

  
    <link rel="top" title="py-earth 0.1.0 documentation" href="index.html"/>
        <link rel="next" title="Gallery" href="auto_examples/index.html"/>
        <link rel="prev" title="Py-earth documentation" href="index.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> py-earth
          

          
          </a>

          
            
            
              <div class="version">
                0.1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="#multivariate-adaptive-regression-splines">Multivariate Adaptive Regression Splines</a></li>
<li class="toctree-l1"><a class="reference internal" href="#a-simple-earth-example">A Simple Earth Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="#bibliography">Bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="#api">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="auto_examples/index.html">Gallery</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">py-earth</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>Introduction</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/content.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="introduction">
<h1>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h1>
<p>The py-earth package is a Python implementation of Jerome Friedman&#8217;s Multivariate Adaptive
Regression Splines algorithm, in the style of scikit-learn.  For more information about Multivariate
Adaptive Regression Splines, see below.  Py-earth is written in Python and Cython.  It
provides an interface that is compatible with scikit-learn&#8217;s Estimator, Predictor, Transformer, and Model
interfaces.  Py-earth accommodates input in the form of numpy arrays, pandas DataFrames, patsy DesignMatrix
objects, or most anything that can be converted into an arrray of floats.  Fitted models can be pickled for
later use.</p>
</div>
<div class="section" id="multivariate-adaptive-regression-splines">
<h1>Multivariate Adaptive Regression Splines<a class="headerlink" href="#multivariate-adaptive-regression-splines" title="Permalink to this headline">¶</a></h1>
<p>Multivariate adaptive regression splines, implemented by the Earth class, is a flexible
regression method that automatically searches for interactions and non-linear
relationships.  Earth models can be thought of as linear models in a higher dimensional
basis space.  Each term in an Earth model is a product of so called &#8220;hinge functions&#8221;.
A hinge function is a function that&#8217;s equal to its argument where that argument is greater
than zero and is zero everywhere else.</p>
<div class="math">
\[\begin{split}\text{h}\left(x-t\right)=\left[x-t\right]_{+}=\begin{cases}
x-t, &amp; x&gt;t\\
0, &amp; x\leq t
\end{cases}\end{split}\]</div>
<img alt="_images/hinge.png" src="_images/hinge.png" />
<p>An Earth model is a linear combination of basis functions, each of which is a product of one
or more of the following:</p>
<blockquote>
<div><ol class="arabic simple">
<li>A constant</li>
<li>Linear functions of input variables</li>
<li>Hinge functions of input variables</li>
</ol>
</div></blockquote>
<p>For example, a simple piecewise linear function in one variable can be expressed
as a linear combination of two hinge functions and a constant (see below).  During fitting, the Earth class
automatically determines which variables and basis functions to use.
The algorithm has two stages.  First, the
forward pass searches for terms that locally minimize squared error loss on the training set.  Next, a pruning pass selects a subset of those
terms that produces a locally minimal generalized cross-validation (GCV) score.  The GCV
score is not actually based on cross-validation, but rather is meant to approximate a true
cross-validation score by penalizing model complexity.  The final result is a set of basis functions
that is nonlinear in the original feature space, may include interactions, and is likely to
generalize well.</p>
<div class="math">
\[y=1-2\text{h}\left(1-x\right)+\frac{1}{2}\text{h}\left(x-1\right)\]</div>
<img alt="_images/piecewise_linear.png" src="_images/piecewise_linear.png" />
</div>
<div class="section" id="a-simple-earth-example">
<h1>A Simple Earth Example<a class="headerlink" href="#a-simple-earth-example" title="Permalink to this headline">¶</a></h1>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">pyearth</span> <span class="k">import</span> <span class="n">Earth</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="k">import</span> <span class="n">pyplot</span>

<span class="c1">#Create some fake data</span>
<span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">m</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">X</span> <span class="o">=</span> <span class="mi">80</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">))</span> <span class="o">-</span> <span class="mi">40</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span><span class="mi">6</span><span class="p">]</span> <span class="o">-</span> <span class="mf">4.0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>

<span class="c1">#Fit an Earth model</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">Earth</span><span class="p">()</span>
<span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>

<span class="c1">#Print the model</span>
<span class="nb">print</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">trace</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">summary</span><span class="p">())</span>

<span class="c1">#Plot the model</span>
<span class="n">y_hat</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span><span class="mi">6</span><span class="p">],</span><span class="n">y</span><span class="p">,</span><span class="s1">&#39;r.&#39;</span><span class="p">)</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span><span class="mi">6</span><span class="p">],</span><span class="n">y_hat</span><span class="p">,</span><span class="s1">&#39;b.&#39;</span><span class="p">)</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;x_6&#39;</span><span class="p">)</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Simple Earth Example&#39;</span><span class="p">)</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<img alt="_images/simple_earth_example.png" src="_images/simple_earth_example.png" />
</div>
<div class="section" id="bibliography">
<h1>Bibliography<a class="headerlink" href="#bibliography" title="Permalink to this headline">¶</a></h1>
<p id="bibtex-bibliography-content-0"><table class="docutils citation" frame="void" id="bjorck1996" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[Bjo96]</a></td><td>Ake Bjorck. <em>Numerical Methods for Least Squares Problems</em>. Society for Industrial and Applied Mathematics, Philadelphia, 1996. ISBN 0898713609.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="friedman1993" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Fri93]</td><td><em>(<a class="fn-backref" href="#id4">1</a>, <a class="fn-backref" href="#id11">2</a>)</em> Jerome&nbsp;H. Friedman. Technical Report No. 110: Fast MARS. Technical Report, Stanford University Department of Statistics, 1993. URL: <a class="reference external" href="http://scholar.google.com/scholar?hl=en&amp;btnG=Search&amp;q=intitle:Fast+MARS#0">http://scholar.google.com/scholar?hl=en&amp;btnG=Search&amp;q=intitle:Fast+MARS#0</a>.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="friedman1991" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Fri91a]</td><td><em>(<a class="fn-backref" href="#id3">1</a>, <a class="fn-backref" href="#id6">2</a>)</em> JH&nbsp;Friedman. Multivariate adaptive regression splines. <em>The annals of statistics</em>, 19(1):1–67, 1991. URL: <a class="reference external" href="http://www.jstor.org/stable/10.2307/2241837">http://www.jstor.org/stable/10.2307/2241837</a>.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="friedman1991a" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Fri91b]</td><td><em>(<a class="fn-backref" href="#id5">1</a>, <a class="fn-backref" href="#id12">2</a>)</em> JH&nbsp;Friedman. Technical Report No. 108: Estimating functions of mixed ordinal and categorical variables using adaptive splines. Technical Report, Stanford University Department of Statistics, 1991. URL: <a class="reference external" href="http://scholar.google.com/scholar?hl=en&amp;btnG=Search&amp;q=intitle:Estimating+functions+of+mixed+ordinal+and+categorical+variables+using+adaptive+splines#0">http://scholar.google.com/scholar?hl=en&amp;btnG=Search&amp;q=intitle:Estimating+functions+of+mixed+ordinal+and+categorical+variables+using+adaptive+splines#0</a>.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="golub1996" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[GVanLoan96]</a></td><td>Gene Golub and Charles Van Loan. <em>Matrix Computations</em>. Johns Hopkins University Press, 3 edition, 1996.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="hastie2009" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[HTF09]</a></td><td>Trevor Hastie, Robert Tibshirani, and Jerome Friedman. <em>Elements of Statistical Learning: Data Mining, Inference, and Prediction</em>. Springer Science+Business Media, New York, 2 edition, 2009.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="millborrow2012" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Mil12]</td><td><em>(<a class="fn-backref" href="#id2">1</a>, <a class="fn-backref" href="#id7">2</a>)</em> Stephen Millborrow. earth: Multivariate Adaptive Regression Spline Models. 2012. URL: <a class="reference external" href="http://cran.r-project.org/web/packages/earth/index.html">http://cran.r-project.org/web/packages/earth/index.html</a>.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="stewart1998" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[Ste98]</a></td><td>G.&nbsp;W. Stewart. <em>Matrix Algorithms Volume 1: Basic Decompositions</em>. Society for Industrial and Applied Mathematics, Philadelphia, 1998. ISBN 0898714141.</td></tr>
</tbody>
</table>
</p>
<p>References <a class="reference internal" href="#hastie2009" id="id1">[HTF09]</a>, <a class="reference internal" href="#millborrow2012" id="id2">[Mil12]</a>, <a class="reference internal" href="#friedman1991" id="id3">[Fri91a]</a>, <a class="reference internal" href="#friedman1993" id="id4">[Fri93]</a>,
and <a class="reference internal" href="#friedman1991a" id="id5">[Fri91b]</a> contain discussions likely to be useful to users of py-earth.
References <a class="reference internal" href="#friedman1991" id="id6">[Fri91a]</a>, <a class="reference internal" href="#millborrow2012" id="id7">[Mil12]</a>, <a class="reference internal" href="#bjorck1996" id="id8">[Bjo96]</a>, <a class="reference internal" href="#stewart1998" id="id9">[Ste98]</a>,
<a class="reference internal" href="#golub1996" id="id10">[GVanLoan96]</a>, <a class="reference internal" href="#friedman1993" id="id11">[Fri93]</a>, and <a class="reference internal" href="#friedman1991a" id="id12">[Fri91b]</a> were useful during the
implementation process.</p>
</div>
<div class="section" id="api">
<h1>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="pyearth.Earth">
<em class="property">class </em><code class="descclassname">pyearth.</code><code class="descname">Earth</code><span class="sig-paren">(</span><em>max_terms=None</em>, <em>max_degree=None</em>, <em>allow_missing=False</em>, <em>penalty=None</em>, <em>endspan_alpha=None</em>, <em>endspan=None</em>, <em>minspan_alpha=None</em>, <em>minspan=None</em>, <em>thresh=None</em>, <em>zero_tol=None</em>, <em>min_search_points=None</em>, <em>check_every=None</em>, <em>allow_linear=None</em>, <em>use_fast=None</em>, <em>fast_K=None</em>, <em>fast_h=None</em>, <em>smooth=None</em>, <em>enable_pruning=True</em>, <em>verbose=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyearth/earth.html#Earth"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyearth.Earth" title="Permalink to this definition">¶</a></dt>
<dd><p>Multivariate Adaptive Regression Splines</p>
<p>A flexible regression method that automatically searches for interactions
and non-linear relationships.  Earth models can be thought of as
linear models in a higher dimensional basis space
(specifically, a multivariate truncated power spline basis).
Each term in an Earth model is a product of so called &#8220;hinge functions&#8221;.
A hinge function is a function that&#8217;s equal to its argument where that
argument is greater than zero and is zero everywhere else.</p>
<p>The multivariate adaptive regression splines algorithm has two stages.
First, the forward pass searches for terms in the truncated power spline
basis that locally minimize the squared error loss of the training set.
Next, a pruning pass selects a subset of those terms that produces
a locally minimal generalized cross-validation (GCV) score.  The GCV score
is not actually based on cross-validation, but rather is meant to
approximate a true cross-validation score by penalizing model complexity.
The final result is a set of terms that is nonlinear in the original
feature space, may include interactions, and is likely to generalize well.</p>
<p>The Earth class supports dense input only.  Data structures from the
pandas and patsy modules are supported, but are copied into numpy arrays
for computation.  No copy is made if the inputs are numpy float64 arrays.
Earth objects can be serialized using the pickle module and copied
using the copy module.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>max_terms</strong> : int, optional (default=2*n + 10, where n is the</p>
<blockquote>
<div><blockquote>
<div><p>number of features)</p>
</div></blockquote>
<p>The maximum number of terms generated by the forward pass.</p>
</div></blockquote>
<p><strong>max_degree</strong> : int, optional (default=1)</p>
<blockquote>
<div><p>The maximum degree of terms generated by the forward pass.</p>
</div></blockquote>
<p><strong>allow_missing</strong> : boolean, optional (default=False)</p>
<blockquote>
<div><p>If True, use missing data method described in [3]. 
Use missing argument to determine missingness or,if X is a pandas 
DataFrame, infer missingness from X.</p>
</div></blockquote>
<p><strong>penalty</strong> : float, optional (default=3.0)</p>
<blockquote>
<div><p>A smoothing parameter used to calculate GCV and GRSQ.
Used during the pruning pass and to determine whether to add a hinge
or linear basis function during the forward pass.
See the d parameter in equation 32, Friedman, 1991.</p>
</div></blockquote>
<p><strong>endspan_alpha</strong> : float, optional, probability between 0 and 1 (default=0.05)</p>
<blockquote>
<div><p>A parameter controlling the calculation of the endspan
parameter (below).  The endspan parameter is calculated as
round(3 - log2(endspan_alpha/n)), where n is the number of features.
The endspan_alpha parameter represents the probability of a run of
positive or negative error values on either end of the data vector
of any feature in the data set.  See equation 45, Friedman, 1991.</p>
</div></blockquote>
<p><strong>endspan</strong> : int, optional (default=-1)</p>
<blockquote>
<div><p>The number of extreme data values of each feature not eligible
as knot locations. If endspan is set to -1 (default) then the
endspan parameter is calculated based on endspan_alpah (above).
If endspan is set to a positive integer then endspan_alpha is ignored.</p>
</div></blockquote>
<p><strong>minspan_alpha</strong> : float, optional, probability between 0 and 1 (default=0.05)</p>
<blockquote>
<div><p>A parameter controlling the calculation of the minspan
parameter (below).  The minspan parameter is calculated as</p>
<blockquote>
<div><p>(int) -log2(-(1.0/(n*count))*log(1.0-minspan_alpha)) / 2.5</p>
</div></blockquote>
<p>where n is the number of features and count is the number of points at
which the parent term is non-zero.  The minspan_alpha parameter
represents the probability of a run of positive or negative error values
between adjacent knots separated by minspan intervening data points.
See equation 43, Friedman, 1991.</p>
</div></blockquote>
<p><strong>minspan</strong> : int, optional (default=-1)</p>
<blockquote>
<div><p>The minimal number of data points between knots.  If minspan is set
to -1 (default) then the minspan parameter is calculated based on
minspan_alpha (above).  If minspan is set to a positive integer then
minspan_alpha is ignored.</p>
</div></blockquote>
<p><strong>thresh</strong> : float, optional (default=0.001)</p>
<blockquote>
<div><p>Parameter used when evaluating stopping conditions for the forward
pass. If either RSQ &gt; 1 - thresh or if RSQ increases by less than
thresh for a forward pass iteration then the forward pass is terminated.</p>
</div></blockquote>
<p><strong>zero_tol</strong> : float, optional (default=1e-12)</p>
<blockquote>
<div><p>Used when determining whether a floating point number is zero during the 
forward pass.  This is important in determining linear dependence and in 
the fast update procedure.  There should normally be no reason to change 
zero_tol from its default.  However, if nans are showing up during the 
forward pass or the forward pass seems to be terminating unexpectedly, 
consider adjusting zero_tol.</p>
</div></blockquote>
<p><strong>min_search_points</strong> : int, optional (default=100)</p>
<blockquote>
<div><p>Used to calculate check_every (below).  The minimum samples necessary
for check_every to be greater than 1.  The check_every parameter
is calculated as</p>
<blockquote>
<div><p>(int) m / min_search_points</p>
</div></blockquote>
<p>if m &gt; min_search_points, where m is the number of samples in the
training set.  If m &lt;= min_search_points then check_every is set to 1.</p>
</div></blockquote>
<p><strong>check_every</strong> : int, optional (default=-1)</p>
<blockquote>
<div><p>If check_every &gt; 0, only one of every check_every sorted data points
is considered as a candidate knot.  If check_every is set to -1 then
the check_every parameter is calculated based on
min_search_points (above).</p>
</div></blockquote>
<p><strong>allow_linear</strong> : bool, optional (default=True)</p>
<blockquote>
<div><p>If True, the forward pass will check the GCV of each new pair of terms
and, if it&#8217;s not an improvement on a single term with no knot
(called a linear term, although it may actually be a product of a linear
term with some other parent term), then only that single, knotless term
will be used.  If False, that behavior is disabled and all terms
will have knots except those with variables specified by the linvars
argument (see the fit method).</p>
</div></blockquote>
<p><strong>use_fast</strong> : bool, optional (default=False)</p>
<blockquote>
<div><p>if True, use the approximation procedure defined in [2] to speed up the
forward pass. The procedure uses two hyper-parameters : fast_K
and fast_h. Check below for more details.</p>
</div></blockquote>
<p><strong>fast_K</strong> : int, optional (default=5)</p>
<blockquote>
<div><p>Only used if use_fast is True. As defined in [2], section 3.0, it
defines the maximum number of basis functions to look at when
we search for a parent, that is we look at only the fast_K top
terms ranked by the mean squared error of the model the last time
the term was chosen as a parent. The smaller fast_K is, the more
gains in speed we get but the more approximate is the result.
If fast_K is the maximum number of terms and fast_h is 1,
the behavior is the same as in the normal case
(when use_fast is False).</p>
</div></blockquote>
<p><strong>fast_h</strong> : int, optional (default=1)</p>
<blockquote>
<div><p>Only used if use_fast is True. As defined in [2], section 4.0, it
determines the number of iterations before repassing through all
the variables when searching for the variable to use for a
given parent term. Before reaching fast_h number of iterations
only the last chosen variable for the parent term is used. The
bigger fast_h is, the more speed gains we get, but the result
is more approximate.</p>
</div></blockquote>
<p><strong>smooth</strong> : bool, optional (default=False)</p>
<blockquote>
<div><p>If True, the model will be smoothed such that it has continuous first
derivatives.
For details, see section 3.7, Friedman, 1991.</p>
</div></blockquote>
<p><strong>enable_pruning</strong> : bool, optional(default=True)</p>
<blockquote>
<div><p>If False, the pruning pass will be skipped.</p>
</div></blockquote>
<p><strong>verbose</strong> : int, optional(default=0)</p>
<blockquote class="last">
<div><p>If verbose &gt;= 1, print out progress information during fitting.  If 
verbose &gt;= 2, also print out information on numerical difficulties
if encountered during fitting. If verbose &gt;= 3, print even more information
that is probably only useful to the developers of py-earth.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id13">[R1]</a></td><td>Friedman, Jerome. Multivariate Adaptive Regression Splines.
Annals of Statistics. Volume 19, Number 1 (1991), 1-67.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id14">[R2]</a></td><td>Fast MARS, Jerome H.Friedman, Technical Report No.110, May 1993.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id15">[R3]</a></td><td>Estimating Functions of Mixed Ordinal and Categorical Variables 
Using Adaptive Splines, Jerome H.Friedman, Technical Report 
No.108, June 1991.</td></tr>
</tbody>
</table>
<p class="rubric">Attributes</p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><cite>coef_</cite></td>
<td>(array, shape = [pruned basis length, number of outputs]) The weights of the model terms that have not been pruned.</td>
</tr>
<tr class="row-even"><td><cite>basis_</cite></td>
<td>(_basis.Basis) An object representing model terms.  Each term is a product of constant, linear, and hinge functions of the input features.</td>
</tr>
<tr class="row-odd"><td><cite>mse_</cite></td>
<td>(float) The mean squared error of the model after the final linear fit. If sample_weight and/or output_weight are given, this score is weighted appropriately.</td>
</tr>
<tr class="row-even"><td><cite>rsq_</cite></td>
<td>(float) The generalized r^2 of the model after the final linear fit. If sample_weight and/or output_weight are given, this score is weighted appropriately.</td>
</tr>
<tr class="row-odd"><td><cite>gcv_</cite></td>
<td>(float) The generalized cross validation (GCV) score of the model after the final linear fit. If sample_weight and/or output_weight are given, this score is weighted appropriately.</td>
</tr>
<tr class="row-even"><td><cite>grsq_</cite></td>
<td>(float) An r^2 like score based on the GCV. If sample_weight and/or output_weight are given, this score is weighted appropriately.</td>
</tr>
<tr class="row-odd"><td><cite>forward_pass_record_</cite></td>
<td>(_record.ForwardPassRecord) An object containing information about the forward pass, such as training loss function values after each iteration and the final stopping condition.</td>
</tr>
<tr class="row-even"><td><cite>pruning_pass_record_</cite></td>
<td>(_record.PruningPassRecord) An object containing information about the pruning pass, such as training loss function values after each iteration and the selected optimal iteration.</td>
</tr>
<tr class="row-odd"><td><cite>xlabels_</cite></td>
<td>(list) List of column names for training predictors. Defaults to [&#8216;x0&#8217;,&#8217;x1&#8217;,....] if column names are not provided.</td>
</tr>
<tr class="row-even"><td><cite>allow_missing_</cite></td>
<td>(list) List of booleans indicating whether each variable is allowed to be missing.  Set during training.  A variable may be missing only if fitting included missing data for that variable.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pyearth.Earth.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em>, <em>sample_weight=None</em>, <em>output_weight=None</em>, <em>missing=None</em>, <em>xlabels=None</em>, <em>linvars=[]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyearth/earth.html#Earth.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyearth.Earth.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit an Earth model to the input data X and y.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>X</strong> : array-like, shape = [m, n] where m is the number of samples</p>
<blockquote>
<div><p>and n is the number of features The training predictors.
The X parameter can be a numpy array, a pandas DataFrame, a patsy
DesignMatrix, or a tuple of patsy DesignMatrix objects as
output by patsy.dmatrices.</p>
</div></blockquote>
<p><strong>y</strong> : array-like, optional (default=None), shape = [m, p] where m is the</p>
<blockquote>
<div><p>number of samples The training response, p the number of outputs.
The y parameter can be a numpy array, a pandas DataFrame,
a Patsy DesignMatrix, or can be left as None (default) if X was
the output of a call to patsy.dmatrices (in which case, X contains
the response).</p>
</div></blockquote>
<p><strong>sample_weight</strong> : array-like, optional (default=None), shape = [m]</p>
<blockquote>
<div><p>where m is the number of samples.
Sample weights for training.  Weights must be greater than or equal
to zero. Rows with zero weight do not contribute at all.
Weights are useful when dealing with heteroscedasticity.  In such
cases, the weight should be proportional to the inverse of the
(known) variance.</p>
</div></blockquote>
<p><strong>output_weight</strong> : array-like, optional (default=None), shape = [p]</p>
<blockquote>
<div><p>where p is the number of outputs.
Output weights for training.  Weights must be greater than or equal
to zero. Output with zero weight do not contribute at all.</p>
</div></blockquote>
<p><strong>missing</strong> : array-like, shape = [m, n] where m is the number of samples</p>
<blockquote>
<div><p>and n is the number of features.
The missing parameter can be a numpy array, a pandas DataFrame, or a 
patsy DesignMatrix.  All entries will be interpreted as boolean 
values, with True indicating the corresponding entry in X should be
interpreted as missing.  If the missing argument not used but the X
argument is a pandas DataFrame, missing will be inferred from X if 
allow_missing is True.</p>
</div></blockquote>
<p><strong>linvars</strong> : iterable of strings or ints, optional (empty by default)</p>
<blockquote>
<div><p>Used to specify features that may only enter terms as linear basis
functions (without knots).  Can include both column numbers and
column names (see xlabels, below).  If left empty, some variables
may still enter linearly during the forward pass if no knot would
provide a reduction in GCV compared to the linear function.
Note that this feature differs from the R package earth.</p>
</div></blockquote>
<p><strong>xlabels</strong> : iterable of strings, optional (empty by default)</p>
<blockquote class="last">
<div><p>The xlabels argument can be used to assign names to data columns.
This argument is not generally needed, as names can be captured
automatically from most standard data structures.
If included, must have length n, where n is the number of features.
Note that column order is used to compute term values and make
predictions, not column names.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyearth.Earth.fit_transform">
<code class="descname">fit_transform</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em>, <em>**fit_params</em><span class="sig-paren">)</span><a class="headerlink" href="#pyearth.Earth.fit_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit to data, then transform it.</p>
<p>Fits transformer to X and y with optional parameters fit_params
and returns a transformed version of X.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>X</strong> : numpy array of shape [n_samples, n_features]</p>
<blockquote>
<div><p>Training set.</p>
</div></blockquote>
<p><strong>y</strong> : numpy array of shape [n_samples]</p>
<blockquote>
<div><p>Target values.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>X_new</strong> : numpy array of shape [n_samples, n_features_new]</p>
<blockquote class="last">
<div><p>Transformed array.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyearth.Earth.forward_pass">
<code class="descname">forward_pass</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em>, <em>sample_weight=None</em>, <em>output_weight=None</em>, <em>missing=None</em>, <em>xlabels=None</em>, <em>linvars=[]</em>, <em>skip_scrub=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyearth/earth.html#Earth.forward_pass"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyearth.Earth.forward_pass" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the forward pass of the multivariate adaptive regression
splines algorithm.  Users will normally want to call the fit method
instead, which performs the forward pass, the pruning pass,
and a linear fit to determine the final model coefficients.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>X</strong> : array-like, shape = [m, n] where m is the number of samples and n is</p>
<blockquote>
<div><p>the number of features The training predictors.  The X parameter can
be a numpy array, a pandas DataFrame, a patsy DesignMatrix, or a
tuple of patsy DesignMatrix objects as output by patsy.dmatrices.</p>
</div></blockquote>
<p><strong>y</strong> : array-like, optional (default=None), shape = [m, p] where m is the</p>
<blockquote>
<div><p>number of samples, p the number of outputs.
The y parameter can be a numpy array, a pandas DataFrame,
a Patsy DesignMatrix, or can be left as None (default) if X was
the output of a call to patsy.dmatrices (in which case, X contains
the response).</p>
</div></blockquote>
<p><strong>sample_weight</strong> : array-like, optional (default=None), shape = [m]</p>
<blockquote>
<div><p>where m is the number of samples.
Sample weights for training.  Weights must be greater than or equal
to zero. Rows with zero weight do not contribute at all.
Weights are useful when dealing with heteroscedasticity.  In such
cases, the weight should be proportional to the inverse of the
(known) variance.</p>
</div></blockquote>
<p><strong>output_weight</strong> : array-like, optional (default=None), shape = [p]</p>
<blockquote>
<div><p>where p is the number of outputs.
The total mean squared error (MSE) is a weighted sum of
mean squared errors (MSE) associated to each output, where
the weights are given by output_weight.
Output weights must be greater than or equal
to zero. Outputs with zero weight do not contribute at all
to the total mean squared error (MSE).</p>
</div></blockquote>
<p><strong>missing</strong> : array-like, shape = [m, n] where m is the number of samples</p>
<blockquote>
<div><p>and n is the number of features.
The missing parameter can be a numpy array, a pandas DataFrame, or a 
patsy DesignMatrix.  All entries will be interpreted as boolean 
values, with True indicating the corresponding entry in X should be
interpreted as missing.  If the missing argument not used but the X
argument is a pandas DataFrame, missing will be inferred from X if 
allow_missing is True.</p>
</div></blockquote>
<p><strong>linvars</strong> : iterable of strings or ints, optional (empty by default)</p>
<blockquote>
<div><p>Used to specify features that may only enter terms as linear basis
functions (without knots).  Can include both column numbers and
column names (see xlabels, below).</p>
</div></blockquote>
<p><strong>xlabels</strong> : iterable of strings, optional (empty by default)</p>
<blockquote class="last">
<div><p>The xlabels argument can be used to assign names to data columns.
This argument is not generally needed, as names can be captured
automatically from most standard data structures.  If included, must
have length n, where n is the number of features.  Note that column
order is used to compute term values and make predictions, not
column names.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyearth.Earth.forward_trace">
<code class="descname">forward_trace</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyearth/earth.html#Earth.forward_trace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyearth.Earth.forward_trace" title="Permalink to this definition">¶</a></dt>
<dd><p>Return information about the forward pass.</p>
</dd></dl>

<dl class="method">
<dt id="pyearth.Earth.get_params">
<code class="descname">get_params</code><span class="sig-paren">(</span><em>deep=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyearth.Earth.get_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Get parameters for this estimator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>deep: boolean, optional</strong></p>
<blockquote>
<div><p>If True, will return the parameters for this estimator and
contained subobjects that are estimators.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>params</strong> : mapping of string to any</p>
<blockquote class="last">
<div><p>Parameter names mapped to their values.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyearth.Earth.get_penalty">
<code class="descname">get_penalty</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyearth/earth.html#Earth.get_penalty"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyearth.Earth.get_penalty" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the penalty parameter being used.  Default is 3.</p>
</dd></dl>

<dl class="method">
<dt id="pyearth.Earth.linear_fit">
<code class="descname">linear_fit</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em>, <em>sample_weight=None</em>, <em>output_weight=None</em>, <em>missing=None</em>, <em>skip_scrub=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyearth/earth.html#Earth.linear_fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyearth.Earth.linear_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the linear least squares problem to determine the coefficients
of the unpruned basis functions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>X</strong> : array-like, shape = [m, n] where m is the number of samples and n</p>
<blockquote>
<div><p>is the number of features The training predictors.  The X parameter
can be a numpy array, a pandas DataFrame, a patsy
DesignMatrix, or a tuple of patsy DesignMatrix objects as output
by patsy.dmatrices.</p>
</div></blockquote>
<p><strong>y</strong> : array-like, optional (default=None), shape = [m, p] where m is the</p>
<blockquote>
<div><p>number of samples, p the number of outputs.
The y parameter can be a numpy array, a pandas DataFrame,
a Patsy DesignMatrix, or can be left as None (default) if X was
the output of a call to patsy.dmatrices (in which case, X contains
the response).</p>
</div></blockquote>
<p><strong>sample_weight</strong> : array-like, optional (default=None), shape = [m]</p>
<blockquote>
<div><p>where m is the number of samples.
Sample weights for training.  Weights must be greater than or equal
to zero. Rows with zero weight do not contribute at all.
Weights are useful when dealing with heteroscedasticity.  In such
cases, the weight should be proportional to the inverse of the
(known) variance.</p>
</div></blockquote>
<p><strong>output_weight</strong> : array-like, optional (default=None), shape = [p]</p>
<blockquote>
<div><p>where p is the number of outputs.
The total mean squared error (MSE) is a weighted sum of
mean squared errors (MSE) associated to each output, where
the weights are given by output_weight.
Output weights must be greater than or equal
to zero. Outputs with zero weight do not contribute at all
to the total mean squared error (MSE).</p>
</div></blockquote>
<p><strong>missing</strong> : array-like, shape = [m, n] where m is the number of samples</p>
<blockquote class="last">
<div><p>and n is the number of features.
The missing parameter can be a numpy array, a pandas DataFrame, or a 
patsy DesignMatrix.  All entries will be interpreted as boolean 
values, with True indicating the corresponding entry in X should be
interpreted as missing.  If the missing argument not used but the X
argument is a pandas DataFrame, missing will be inferred from X if 
allow_missing is True.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyearth.Earth.predict">
<code class="descname">predict</code><span class="sig-paren">(</span><em>X</em>, <em>missing=None</em>, <em>skip_scrub=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyearth/earth.html#Earth.predict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyearth.Earth.predict" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Predict the response based on the input data X.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>X</strong> : array-like, shape = [m, n] where m is the number of samples and n</p>
<blockquote>
<div><blockquote>
<div><p>is the number of features
The training predictors.  The X parameter can be a numpy
array, a pandas DataFrame, or a patsy DesignMatrix.</p>
</div></blockquote>
<dl class="docutils">
<dt>missing</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">array-like, shape = [m, n] where m is the number of samples</span><dd><p class="first last">and n is the number of features.
The missing parameter can be a numpy array, a pandas DataFrame, or a 
patsy DesignMatrix.  All entries will be interpreted as boolean 
values, with True indicating the corresponding entry in X should be
interpreted as missing.  If the missing argument not used but the X
argument is a pandas DataFrame, missing will be inferred from X if 
allow_missing is True.</p>
</dd>
</dl>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>y</strong> : array of shape = [m] or [m, p] where m is the number of samples</p>
<blockquote class="last">
<div><p>and p is the number of outputs
The predicted values.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyearth.Earth.predict_deriv">
<code class="descname">predict_deriv</code><span class="sig-paren">(</span><em>X</em>, <em>variables=None</em>, <em>missing=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyearth/earth.html#Earth.predict_deriv"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyearth.Earth.predict_deriv" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Predict the first derivatives of the response based on the input data X.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>X</strong> : array-like, shape = [m, n] where m is the number of samples and n is</p>
<blockquote>
<div><blockquote>
<div><p>the number of features The training predictors.  The X parameter can
be a numpy array, a pandas DataFrame, or a patsy DesignMatrix.</p>
</div></blockquote>
<dl class="docutils">
<dt>missing</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">array-like, shape = [m, n] where m is the number of samples</span><dd><p class="first last">and n is the number of features.
The missing parameter can be a numpy array, a pandas DataFrame, or a 
patsy DesignMatrix.  All entries will be interpreted as boolean 
values, with True indicating the corresponding entry in X should be
interpreted as missing.  If the missing argument not used but the X
argument is a pandas DataFrame, missing will be inferred from X if 
allow_missing is True.</p>
</dd>
<dt>variables</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">list</span><dd><p class="first last">The variables over which derivatives will be computed.  Each column
in the resulting array corresponds to a variable.  If not
specified, all variables are used (even if some are not relevant
to the final model and have derivatives that are identically zero).</p>
</dd>
</dl>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>X_deriv</strong> : array of shape = [m, n, p] where m is the number of samples, n</p>
<blockquote class="last">
<div><p>is the number of features if &#8216;variables&#8217; is not specified otherwise it 
is len(variables) and p is the number of outputs.
For each sample, X_deriv represents the first derivative of each response 
with respect to each variable.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyearth.Earth.pruning_pass">
<code class="descname">pruning_pass</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em>, <em>sample_weight=None</em>, <em>output_weight=None</em>, <em>missing=None</em>, <em>skip_scrub=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyearth/earth.html#Earth.pruning_pass"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyearth.Earth.pruning_pass" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the pruning pass of the multivariate adaptive regression
splines algorithm.  Users will normally want to call the fit
method instead, which performs the forward pass, the pruning
pass, and a linear fit to determine the final model coefficients.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>X</strong> : array-like, shape = [m, n] where m is the number of samples</p>
<blockquote>
<div><p>and n is the number of features The training predictors.
The X parameter can be a numpy array, a pandas DataFrame, a patsy
DesignMatrix, or a tuple of patsy DesignMatrix objects as output
by patsy.dmatrices.</p>
</div></blockquote>
<p><strong>y</strong> : array-like, optional (default=None), shape = [m, p] where m is the</p>
<blockquote>
<div><p>number of samples, p the number of outputs.
The y parameter can be a numpy array, a pandas DataFrame,
a Patsy DesignMatrix, or can be left as None (default) if X was
the output of a call to patsy.dmatrices (in which case, X contains
the response).</p>
</div></blockquote>
<p><strong>sample_weight</strong> : array-like, optional (default=None), shape = [m]</p>
<blockquote>
<div><p>where m is the number of samples.
Sample weights for training.  Weights must be greater than or equal
to zero. Rows with zero weight do not contribute at all.
Weights are useful when dealing with heteroscedasticity.  In such
cases, the weight should be proportional to the inverse of the
(known) variance.</p>
</div></blockquote>
<p><strong>output_weight</strong> : array-like, optional (default=None), shape = [p]</p>
<blockquote>
<div><p>where p is the number of outputs.
The total mean squared error (MSE) is a weighted sum of
mean squared errors (MSE) associated to each output, where
the weights are given by output_weight.
Output weights must be greater than or equal
to zero. Outputs with zero weight do not contribute at all
to the total mean squared error (MSE).</p>
</div></blockquote>
<p><strong>missing</strong> : array-like, shape = [m, n] where m is the number of samples</p>
<blockquote class="last">
<div><p>and n is the number of features.
The missing parameter can be a numpy array, a pandas DataFrame, or a 
patsy DesignMatrix.  All entries will be interpreted as boolean 
values, with True indicating the corresponding entry in X should be
interpreted as missing.  If the missing argument not used but the X
argument is a pandas DataFrame, missing will be inferred from X if 
allow_missing is True.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyearth.Earth.pruning_trace">
<code class="descname">pruning_trace</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyearth/earth.html#Earth.pruning_trace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyearth.Earth.pruning_trace" title="Permalink to this definition">¶</a></dt>
<dd><p>Return information about the pruning pass.</p>
</dd></dl>

<dl class="method">
<dt id="pyearth.Earth.score">
<code class="descname">score</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em>, <em>sample_weight=None</em>, <em>output_weight=None</em>, <em>missing=None</em>, <em>skip_scrub=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyearth/earth.html#Earth.score"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyearth.Earth.score" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the generalized r^2 of the model on data X and y.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>X</strong> : array-like, shape = [m, n] where m is the number of samples</p>
<blockquote>
<div><p>and n is the number of features The training predictors.
The X parameter can be a numpy array, a pandas DataFrame, a patsy
DesignMatrix, or a tuple of patsy DesignMatrix objects as output
by patsy.dmatrices.</p>
</div></blockquote>
<p><strong>y</strong> : array-like, optional (default=None), shape = [m, p] where m is the</p>
<blockquote>
<div><p>number of samples, p the number of outputs.
The y parameter can be a numpy array, a pandas DataFrame,
a Patsy DesignMatrix, or can be left as None (default) if X was
the output of a call to patsy.dmatrices (in which case, X contains
the response).</p>
</div></blockquote>
<p><strong>sample_weight</strong> : array-like, optional (default=None), shape = [m]</p>
<blockquote>
<div><p>where m is the number of samples.
Sample weights for training.  Weights must be greater than or equal
to zero. Rows with zero weight do not contribute at all.
Weights are useful when dealing with heteroscedasticity.  In such
cases, the weight should be proportional to the inverse of the
(known) variance.</p>
</div></blockquote>
<p><strong>output_weight</strong> : array-like, optional (default=None), shape = [p]</p>
<blockquote>
<div><p>where p is the number of outputs.
The total mean squared error (MSE) is a weighted sum of
mean squared errors (MSE) associated to each output, where
the weights are given by output_weight.
Output weights must be greater than or equal
to zero. Outputs with zero weight do not contribute at all
to the total mean squared error (MSE).</p>
</div></blockquote>
<p><strong>missing</strong> : array-like, shape = [m, n] where m is the number of samples</p>
<blockquote>
<div><p>and n is the number of features.
The missing parameter can be a numpy array, a pandas DataFrame, or a 
patsy DesignMatrix.  All entries will be interpreted as boolean 
values, with True indicating the corresponding entry in X should be
interpreted as missing.  If the missing argument not used but the X
argument is a pandas DataFrame, missing will be inferred from X if 
allow_missing is True.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>score</strong> : float with a maximum value of 1 (it can be negative).</p>
<blockquote class="last">
<div><p>The score is the generalized r^2 of the model on data X and y, the higher
the score the better the fit is.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyearth.Earth.score_samples">
<code class="descname">score_samples</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em>, <em>missing=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyearth/earth.html#Earth.score_samples"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyearth.Earth.score_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate sample-wise fit scores.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>X</strong> : array-like, shape = [m, n] where m is the number of samples</p>
<blockquote>
<div><p>and n is the number of features The training predictors.
The X parameter can be a numpy array, a pandas DataFrame, a patsy
DesignMatrix, or a tuple of patsy DesignMatrix objects as output
by patsy.dmatrices.</p>
</div></blockquote>
<p><strong>y</strong> : array-like, optional (default=None), shape = [m, p] where m is the</p>
<blockquote>
<div><p>number of samples, p the number of outputs.
The y parameter can be a numpy array, a pandas DataFrame,
a Patsy DesignMatrix, or can be left as None (default) if X was
the output of a call to patsy.dmatrices (in which case, X contains
the response).</p>
</div></blockquote>
<p><strong>missing</strong> : array-like, shape = [m, n] where m is the number of samples</p>
<blockquote>
<div><p>and n is the number of features.
The missing parameter can be a numpy array, a pandas DataFrame, or a 
patsy DesignMatrix.  All entries will be interpreted as boolean 
values, with True indicating the corresponding entry in X should be
interpreted as missing.  If the missing argument not used but the X
argument is a pandas DataFrame, missing will be inferred from X if 
allow_missing is True.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>scores</strong> : array of shape=[m, p] of floats with maximum value of 1 (it can be negative).</p>
<blockquote class="last">
<div><p>The scores represent how good each output of each example is predicted,
a perfect score would be 1 (the score can be negative).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyearth.Earth.set_params">
<code class="descname">set_params</code><span class="sig-paren">(</span><em>**params</em><span class="sig-paren">)</span><a class="headerlink" href="#pyearth.Earth.set_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parameters of this estimator.</p>
<p>The method works on simple estimators as well as on nested objects
(such as pipelines). The former have parameters of the form
<code class="docutils literal"><span class="pre">&lt;component&gt;__&lt;parameter&gt;</span></code> so that it&#8217;s possible to update each
component of a nested object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">self</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyearth.Earth.summary">
<code class="descname">summary</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyearth/earth.html#Earth.summary"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyearth.Earth.summary" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a string describing the model.</p>
</dd></dl>

<dl class="method">
<dt id="pyearth.Earth.trace">
<code class="descname">trace</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyearth/earth.html#Earth.trace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyearth.Earth.trace" title="Permalink to this definition">¶</a></dt>
<dd><p>Return information about the forward and pruning passes.</p>
</dd></dl>

<dl class="method">
<dt id="pyearth.Earth.transform">
<code class="descname">transform</code><span class="sig-paren">(</span><em>X</em>, <em>missing=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyearth/earth.html#Earth.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyearth.Earth.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform X into the basis space.  Normally, users will call the
predict method instead, which both transforms into basis space
calculates the weighted sum of basis terms to produce a prediction
of the response.  Users may wish to call transform directly in some
cases.  For example, users may wish to apply other statistical or
machine learning algorithms, such as generalized linear regression,
in basis space.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>X</strong> : array-like, shape = [m, n] where m is the number of samples and n</p>
<blockquote>
<div><p>is the number of features
The training predictors.  The X parameter can be a numpy array, a
pandas DataFrame, or a patsy DesignMatrix.</p>
</div></blockquote>
<p><strong>missing</strong> : array-like, shape = [m, n] where m is the number of samples</p>
<blockquote>
<div><p>and n is the number of features.
The missing parameter can be a numpy array, a pandas DataFrame, or a 
patsy DesignMatrix.  All entries will be interpreted as boolean 
values, with True indicating the corresponding entry in X should be
interpreted as missing.  If the missing argument not used but the X
argument is a pandas DataFrame, missing will be inferred from X if 
allow_missing is True.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">B: array of shape [m, nb_terms] where m is the number of samples and nb_terms</p>
<blockquote class="last">
<div><p>is the number of terms (or basis functions) obtained after fitting (which is the 
number of elements of the attribute <cite>basis_</cite>). B represents the values of
the basis functions evaluated at each sample.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="auto_examples/index.html" class="btn btn-neutral float-right" title="Gallery" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral" title="Py-earth documentation" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2013, Jason Rudy.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>